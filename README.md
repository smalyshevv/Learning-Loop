## Пример контейнеров с "кастомным" клиент-серверным взаимодействием 

### Исходный код докер-файлов
* Сервер - [perfectstore-master](perfectstore-master/Dockerfile)
* Клиент - [psplayer-main](psplayer-main/Dockerfile)

### О задаче
Задача является интерактивной экономической PvE игрой, в которой решение участника путем ограниченного по времени взаимодействия с сервером по специальному API должно получить максимальную "прибыль", управляя виртуальным "магазином". 

Игровая логика реализована на Java (Spring Framework) в виде двух контейнеров. Серверный контейнер в проверяющей системе стартует первым и до таймаута ожидает подключения Клиента. После успешного подключения Сервер начинает симуляцию игровой ситуации и до истечения отведенного правилами времени отвечает на запросы Клиента. 

Клиентский контейнер участники соревнования готовили и собирали самостоятельно. В примере приведен "Quick start" - образец примитивного по логике, но верного по технической реализации решения, которое публиковалось для участников.


### Полное Описание задачи 
Ссылка на задачу на AllCups - [Идеальный магазин](https://cups.online/ru/tasks/1116).

Кроме того, см. [readme](perfectstore-master/readme.md) сервера.

### Общие принципы запуска проверяющих контейнеров
1. Статические данные на вход контейнера передаются путем монтирования в его файловую систему при старте. Под статическими данными подразумеваются данные зависящие от конкретной задачи (например эталонные правильные ответы, файлы конфигурации серверного приложения и т.п.). При локальном тестировании монтирование статических данных можно сделать передачей соответствующих параметров команде docker run, например:
```docker run --mount "type=bind,src=$(pwd)/my_task/tests,dst=/tmp/data"``` 
2. При этом внутри контейнера путь к примонтированному каталогу будет доступен в переменной окружения. Например: ```os.environ.get("MOUNT_POINT")```
3. Аналогичным образом передается точка монтирования json файла с результатами проверки.
4. Формат файла результата проверки зависит от "механики" задачи - см. конкретные примеры. В нем, как минимум, содержатся набранные решением баллы и/или тексты ошибок, и как максимум - может присутствовать детализация хода проверки, необходимая в рамках конкретной механики (баллы за тесты, лог проверки и т.п.).
5. Номера портов для внутренней сети между контейнерами, названия методов API и тому подобные настройки можно также передавать контейнеру через переменные окружения. Но это не является обязательным - все настройки можно "зашить" в контейнере, если не предполагается многократное использование одного и того же контейнера с разными настройками / данными (в разных задачах, например).

